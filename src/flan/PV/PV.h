#pragma once

#include <functional>
#include <map>
#include <complex>

#include "flan/PV/PVBuffer.h"
#include "flan/Function.h"
#include "flan/Utility/Interpolator.h"
#include "flan/Utility/Rect.h"
#include "flan/PV/PrismFunc.h"

struct fftwf_plan_s;

namespace flan {

class Audio;
class Graph;

//! Phase Vocoder (PV) Data Algorithms
/** This is a stateless wrapper of flan::PVBuffer which contains all relevant algorithms and utilities available
 *	in flan for manipulating PV buffers.
 *
 *	All methods are const and have no side effects outside of PV::graph, which saves a bmp file.
 *	See PVBuffer for a description of Phase Vocoder (PV) Data.
 */
class PV : public PVBuffer
{
public:

	using Vec = const std::vector<const PV &> &;

	/** Constructs 0 size PV with default PVBuffer::Format. */
	PV() : PVBuffer( PVBuffer::Format() ) {}

	/** Constructs a PV with the Format other but with an initialized buffer.
	 *	\param other Format for the constructed PV
	 */
	PV( const PVBuffer::Format & other ) : PVBuffer( other ) {}

	/** Constructs a PV from the .ana file at filename.
	 *	\param filename A .flan filename to load. 
			This file type is flan specific and is generated by PVBuffer::save.
	 */
	PV( const std::string & filename ) : PVBuffer( filename ) {}

	/** PV is a stateless wrapper, so it can be constructed from a buffer
	 */
	PV( PVBuffer && other ) : PVBuffer( std::move( other ) ) {}



	//============================================================================================================================================================
	// Conversions
	//============================================================================================================================================================

	/** Transforms this PV to an Audio using the overlaps and samplerate given in format. 
	 */
	Audio convertToAudio( flan_CANCEL_ARG ) const;

	/** The inverse transform of Audio::convertToMidSidePV.
	 */
	Audio convertToLeftRightAudio( flan_CANCEL_ARG ) const;

	/** Converts the PV to a spectrograph bmp.
	 *  \param domain The time/frequency rectangle to graph. Negative 1 for time or frequency end will use the maximum.
	 *  \param width The bmp width.
	 *  \param height The bmp height.
	 */
	Graph convertToGraph( Rect domain = { 0, 0, -1, -1 }, Pixel width = -1, Pixel height = -1, float timelineScale = 0 ) const;

	/** Creates and saves a bmp spectrograph of the PV, then returns this.
	 *	\param filename A filename at which to save the generated bmp.
	 *  \param domain The time/frequency rectangle to graph. Negative 1 for time or frequency end will use the maximum.
	 *  \param width The bmp width.
	 *  \param height The bmp height.
	 */
	const PV & saveToBMP( const std::string & filename, Rect domain = { 0, 0, -1, -1 }, Pixel width = -1, Pixel height = -1 ) const;



	//============================================================================================================================================================
	// Contours
	//============================================================================================================================================================

	/** Container for salience (percieved volume) extracted by PV::getSalience.
	 */
	struct Salience
		{
		float & get( Frame f, Bin b ) { return buffer[ f * numBins + b ]; }
		Frame numFrames;
		Bin numBins;
		std::vector<float> buffer;
		};

	/** This attempts to find the percieved volume at every tenth of a note over time. Meant to be used by PV::getContours.
	 *    Note this doesn't use a percieved volume filter like it maybe should. I didn't want to deal with it.
	 *	\param channel The channel to analyze.
	 *	\param minFreq Frequency of the lowest pitch bin.
	 *	\param maxFreq Frequency of the highest pitch bin.
	 */
	Salience getSalience( Channel channel, Frequency minFreq = 55, Frequency maxFreq = 1760 ) const;

	/** Container for a contour (note) extracted by PV::getContours, with some commonly needed details.
	 */
	struct Contour
		{
		float pitchMean;
		float pitchSD;
		float salienceMean;
		float salienceSD;

		Frame startFrame;
		std::vector<vec2> bins; // Each vec2 contains { pitchBin, mag (?) }
		};

	/** This is a piece of the melodia melody finding algorithm, which attempts to extract note information from PV data.
	 *  \param channel The channel to analyze.
	 *  \param minFreq
	 *  \param maxFreq
	 *  \param filterShort Contours with lengths less than this will be removed.
	 *  \param filterQuiet Contours with salienceMean less than the largest salienceMean divided by this are removed
	 */
	std::vector<Contour> getContours( Channel channel, Frequency minFreq = 55, Frequency maxFreq = 1760, Frame filterShort = 30, float filterQuiet = 20, flan_CANCEL_ARG ) const;

	/** Prism, in theory, allows complete control over the frequency and magnitude of every harmonic of every note in the input.
	 *  \param harmonicFunction This takes the global or local time (see perNote), the harmonic index (starting at 0), the base frequency and the 
	 *  	magnitudes of all harmonics. It should return the MF that the input harmonic should be modified to. This function type is defined in Function.h.
	 *  \param perNote This decides if the time passed to harmonicFunction should be the time elapsed since the start of the PV (false), or the start of the contour (true).
	 */
	PV prism( const PrismFunc & harmonicFunction, bool perNote = true, flan_CANCEL_ARG ) const;

	//============================================================================================================================================================
	// Utility
	//============================================================================================================================================================

	/** Returns a single frame from the input. 
	 *	The returned frame in a linear interpolation of the frame surrounding the selected time.
	 *	\param time The time at which the frame should be taken. 
	 */
	PV getFrame( Second time ) const;

	/** This computes a weighted approximation of the 4 surrounding bins using the provided interpolator */
	MF getBinInterpolated( Channel channel, float frame, float bin, Interpolator interp = Interpolators::linear ) const;
	MF getBinInterpolated( Channel channel, float frame, Bin bin, Interpolator interp = Interpolators::linear ) const;
	MF getBinInterpolated( Channel channel, Frame frame, float bin, Interpolator interp = Interpolators::linear ) const;



	//============================================================================================================================================================
	// Selection
	//============================================================================================================================================================

	/** Every time/frequency point in the output PV will read an arbitrary point in the input determined by selector.
	 *	Selected non-integer coordinates will interpolate surrounding integer coordinates using interp.
	 *	\param length The length of the output PV
	 *	\param selector This function takes each time/frequency point in the output and returns 
	 *		the time/frequency that should be read from the input into that output
	 *	\param interpolateFrames Decides if selecting a point between frames should interpolate the surrounding frames or round to the nearest frame.
	 		Using interpolation takes around twice as long to compute.
	 *	\param interp This determines how input points surrounding selected points are interpolated
	 */
	PV select( Second length, const Func2x2 & selector, bool interpolateFrames = false, Interpolator interp = Interpolators::linear ) const;

	/** This is a classic "time-freeze" effect. At supplied times playback is "frozen", repeating the current frame 
	 *	(or a linear interpolation of surrounding frames), for a specified amount of time. After this time has elapsed,
	 *	playback resumes until another freeze time is encountered.
	 *	\param timing Each element of timing describes a point of time to freeze, and for 
	 *		how long it should be frozen, in that order
	 */
	PV freeze( const std::vector<std::array<Second,2>> & timing ) const;



	//============================================================================================================================================================
	// Resampling
	//============================================================================================================================================================

	/** Each input bin is mapped to an arbitrary output point by mod. 
	 *	Every quad in the input is thus mapped to a quad in the output. 
	 *	The output points within that quad are given an average of any data already within the bin 
	 *	and the four input bins that made up the quad being mapped.
	 *	Quad averages are decided using the interpolator argument and the algorithm described here: 
	 *	https://www.particleincell.com/2012/quad-interpolation/
	 *	\param mod Takes and returns time/frequency pairs as either flan::vec2 or std::complex<float>
	 *	\param interp Interpolator used in quad mapping
	 */
	PV modify( const Func2x2 & mod, Interpolator interp = Interpolators::linear ) const;

	/** This is functionally equivalent to using PV::modify_cpu and only outputting the input time
	 *	\param mod Takes time/frequency pairs and returns frequency
	 *	\param interp Interpolator used in frequency mapping
	 */
	PV modifyFrequency( const Func2x1 & mod, Interpolator = Interpolators::linear ) const;

	/** This is functionally equivalent to using PV::modify_cpu and only outputting the input frequency
	 *	\param mod Takes time/frequency pairs and returns time
	 *	\param interp Interpolator used in time mapping
	 */
	PV modifyTime( const Func2x1 & mod, Interpolator = Interpolators::linear ) const;

	/** This is functionally equivalent to using PV::modifyFrequency with the mod output multiplied by input frequency
	 *	\param factor Takes time/frequency pairs and returns frequency multiplier
	 *	\param interp Disabled for gpu methods.
	 */
	PV repitch( const Func2x1 & factor, Interpolator = Interpolators::linear ) const;

	/** This is functionally equivalent to using PV::modifySecond with the mod output multiplied by input time
	 *	\param factor Takes time/frequency pairs and returns time multiplier
	 *	\param interp Interpolator used in frequency mapping
	 */
	PV stretch( const Func2x1 & factor, Interpolator = Interpolators::linear ) const;

	/** This is close to PV::stretch, but can only expand the input by integer quantities at any given time.
	 *	It is also restricted to choosing the local expansion amount as a function of time, not frequency.
	 *	Spline interpolation is used to fill the expanded space.
	 *	\param expansion This returns the local expansion amount as a function of time. 
	 *		Output will be rounded to the nearest integer and clamped to positive integers.
	 */
	PV stretch_spline( const Func1x1 & expansion ) const;

	/** This is functionally equivalent to stretching the input down by factor, and then up.
	 *	Resolution is lost, but the lost resolution is filled via interpolation
	 *	\param eventsPerSecond The number of MFs per second that are not removed before interpolation.
	 *	\param interp Interpolator deciding how lost frames are restored from their surroundings
	 */
	PV desample( const Func2x1 & eventsPerSecond, Interpolator interp = Interpolators::linear ) const;

	/** Warning: this process can produce very loud outputs with unscrupulouss parameters.
	 *	The input is left alone until startTime. Between startTime and endTime the output is an interpolation
	 *	of the frames at startTime and endTime. After endTime, the interpolation continues into the realm of extrapolation
	 *	for extrapDuration seconds. High frequency partials in the input can cause unpleasant sine sweeps in the output,
	 *	so you may want to use a mild low pass filter before processing.
	 *	\param startTime Second at which interpolation starts.
	 *	\param endTime Second at which interpolation ends and extrapolation begins. -1 indicates end of file.
	 *	\param extrapDuration Duration of the extrapolation
	 *	\param interp Interpolator used throughout
	 */
	PV timeExtrapolate( Second startTime, Second endTime, Second extrapDuration, Interpolator interp = Interpolators::linear) const;


	//============================================================================================================================================================
	// Generation
	//============================================================================================================================================================

	/** Generates a PV from a spectrum.
	 *	\param length 
	 *	\param freq
	 *	\param harmonicWeights This takes time and a harmonic index, and returns a magnitude.
	 */
	static PV synthesize( Second length, Func1x1 freq, const Func2x1 & harmonicWeights );



	//============================================================================================================================================================
	// Extras
	//============================================================================================================================================================

	/** For all frequencies, every octave above it is set to a copy of the base, scaled by seriesScale
	 *	\param seriesScale The scaling function. The inputs to this are time and harmonic index starting at 0.
	 */
	PV addOctaves( const Func2x1 & seriesScale ) const;

	/** For all frequencies, every harmonic above it is set to a copy of the base, scaled by seriesScale
	 *	\param seriesScale The scaling function. The inputs to this are time and harmonic index starting at 0.
	 */
	PV addHarmonics( const Func2x1 & seriesScale ) const;

	/** Replaces the Amplitudes (Magnitudes) of bins in the input with those in ampSource
	 *	\param ampSource Source PV from which to draw amplitudes
	 *	\param amount An amount of 1 fully replaces the amplitudes, 0 does nothing, and amounts between
	 *		give a linear interpolation of the two.
	 *	\returns A PV with dimensions equal to the shorter of this and ampSource
	 */
	PV replaceAmplitudes( const PV & ampSource, const Func2x1 & amount = 1 ) const;

	/** Subtracts the Amplitudes (Magnitudes) of bins in other with those in this
	 *	\param ampSource Source PV from which to draw amplitudes to subtract.
	 *	\param amount A scalar on the subtraction amount. This isn't clamped to [0,1].
	 *	\returns A PV with dimensions equal to the shorter of this and ampSource.
	 */
	PV subtractAmplitudes( const PV & other, const Func2x1 & amount = 1 ) const;

	/** Passes each MF through the shaper.
	 *	\param shaper A function which takes each input MF and returns an MF to be written to the output.
	 *	\param useShiftAlignment If enabled, for each input MF the difference between the bin the MF came from and the bin its
	 *		frequency would naturally land in is found. That is the bin shift. After shaping, rather than placing data back into the bin it 
	 *		came from, the natural bin for the shaped frequency is found, and the bin shift is added. This makes an effort to maintain the
	 *		cohesion of partials when the shaper is shifting frequency information.
	 */
	PV shape( const Function<MF,MF> & shaper, bool useShiftAlignment = false ) const;

	/** Modifies the input data in random ways using normal distributions.
	 *	\param magSigma Standard deviation for magnitude distribution.
	 *	\param frqSigma Standard deviation for frequency distribution.
	 *	\param damping How much each perturbation should be brought back towards zero per frame.
	 		One will do nothing, zero gives complete damping, and values over one will cause the sound to explode.
	 */
	PV perturb( const Func2x1 & magSigma, const Func2x1 & frqSigma, float damping = 0.99 ) const;

	/** At any given time, numPartials should return a number of bins, N, to retain.
	 *	The N loudest bins are copied to the output.
	 *	All other output bins are 0 filled.
	 *	\param numPartials Number of partials to retain as a function of time
	 */
	PV retainNLoudestPartials( const Function<Second, Bin> & numPartials ) const;

	/** At any given time, numPartials should return a number of bins, N, to remove.
	 *	The N loudest bin positions are 0 filled in the output.
	 *	All other bins are copied to the output.
	 *	\param numPartials Number of partials to remove as a function of time
	 */
	PV removeNLoudestPartials( const Function<Second, Bin> & numPartials ) const;

	/** Each bin has its frequency copied to subsequent output bins with decaying magnitude until a 
	 *	bin with magnitude greater than the current decayed magnitude is read from the input. 
	 *	The frequency of the output at that point then changes to that of the louder bin.
	 *	\param decay This returns the decay amount per second at every time/frequency input.
	 *		For example, a constant decay of .5 applied to an impulse will lose half it's magnitude every second.
	 *	\param length Because the decay is exponential, an output length is needed. 
	 */
	PV resonate( Second length, const Func2x1 & decay ) const;

};

} // End namespace flan

