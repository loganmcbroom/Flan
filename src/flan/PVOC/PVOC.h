#pragma once

#include <functional>
#include <map>
#include <complex>

#include "flan/PVOC/PVOCBuffer.h"
#include "flan/Function.h"
#include "flan/Utility/Interpolator.h"
#include "flan/Utility/Rect.h"
#include "flan/PVOC/PrismFunc.h"

struct fftwf_plan_s;

namespace flan {

class Audio;
class Graph;

//! Phase Vocoder (PVOC) Data Algorithms
/** This is a stateless wrapper of flan::PVOCBuffer which contains all relevant algorithms and utilities available
 *	in flan for manipulating PVOC buffers.
 *
 *	All methods are const and have no side effects outside of PVOC::graph, which saves a bmp file.
 *	See PVOCBuffer for a description of Phase Vocoder (PVOC) Data.
 */
class PVOC : public PVOCBuffer
{
public:

	using Vec = const std::vector<const PVOC &> &;

	/** Constructs 0 size PVOC with default PVOCBuffer::Format. */
	PVOC() : PVOCBuffer( PVOCBuffer::Format() ) {}

	/** Constructs a PVOC with the Format other but with an initialized buffer.
	 *	\param other Format for the constructed PVOC
	 */
	PVOC( const PVOCBuffer::Format & other ) : PVOCBuffer( other ) {}

	/** Constructs a PVOC from the .ana file at filename.
	 *	\param filename A .flan filename to load. 
			This file type is flan specific and is generated by PVOCBuffer::save.
	 */
	PVOC( const std::string & filename ) : PVOCBuffer( filename ) {}

	/** PVOC is a stateless wrapper, so it can be constructed from a buffer
	 */
	PVOC( PVOCBuffer && other ) : PVOCBuffer( std::move( other ) ) {}



	//============================================================================================================================================================
	// Conversions
	//============================================================================================================================================================

	/** Transforms this PVOC to an Audio using the overlaps and samplerate given in format. 
	 */
	Audio convertToAudio( flan_CANCEL_ARG ) const;

	/** The inverse transform of Audio::convertToMidSidePVOC.
	 */
	Audio convertToLeftRightAudio( flan_CANCEL_ARG ) const;

	/** Converts the PVOC to a spectrograph bmp.
	 *  \param domain The time/frequency rectangle to graph. Negative 1 for time or frequency end will use the maximum.
	 *  \param width The bmp width.
	 *  \param height The bmp height.
	 */
	Graph convertToGraph( Rect domain = { 0, 0, -1, -1 }, Pixel width = -1, Pixel height = -1, float timelineScale = 0 ) const;

	/** Creates and saves a bmp spectrograph of the PVOC, then returns this.
	 *	\param filename A filename at which to save the generated bmp.
	 *  \param domain The time/frequency rectangle to graph. Negative 1 for time or frequency end will use the maximum.
	 *  \param width The bmp width.
	 *  \param height The bmp height.
	 */
	const PVOC & saveToBMP( const std::string & filename, Rect domain = { 0, 0, -1, -1 }, Pixel width = -1, Pixel height = -1 ) const;



	//============================================================================================================================================================
	// Contours
	//============================================================================================================================================================

	/** Container for salience (percieved volume) extracted by PVOC::getSalience.
	 */
	struct Salience
		{
		float & get( Frame f, Bin b ) { return buffer[ f * numBins + b ]; }
		Frame numFrames;
		Bin numBins;
		std::vector<float> buffer;
		};

	/** This attempts to find the percieved volume at every tenth of a note over time. Meant to be used by PVOC::getContours.
	 *    Note this doesn't use a percieved volume filter like it maybe should. I didn't want to deal with it.
	 *	\param channel The channel to analyze.
	 *	\param minFreq Frequency of the lowest pitch bin.
	 *	\param maxFreq Frequency of the highest pitch bin.
	 */
	Salience getSalience( Channel channel, Frequency minFreq = 55, Frequency maxFreq = 1760 ) const;

	/** Container for a contour (note) extracted by PVOC::getContours, with some commonly needed details.
	 */
	struct Contour
		{
		float pitchMean;
		float pitchSD;
		float salienceMean;
		float salienceSD;

		Frame startFrame;
		std::vector<vec2> bins; // Each vec2 contains { pitchBin, mag (?) }
		};

	/** This is a piece of the melodia melody finding algorithm, which attempts to extract note information from PVOC data.
	 *  \param channel The channel to analyze.
	 *  \param minFreq
	 *  \param maxFreq
	 *  \param filterShort Contours with lengths less than this will be removed.
	 *  \param filterQuiet Contours with salienceMean less than the largest salienceMean divided by this are removed
	 */
	std::vector<Contour> getContours( Channel channel, Frequency minFreq = 55, Frequency maxFreq = 1760, Frame filterShort = 30, float filterQuiet = 20, flan_CANCEL_ARG ) const;

	/** Prism, in theory, allows complete control over the frequency and magnitude of every harmonic of every note in the input.
	 *  \param harmonicFunction This takes the global or local time (see perNote), the harmonic index (starting at 0), the base frequency and the 
	 *  	magnitudes of all harmonics. It should return the MF that the input harmonic should be modified to. This function type is defined in Function.h.
	 *  \param perNote This decides if the time passed to harmonicFunction should be the time elapsed since the start of the PVOC (false), or the start of the contour (true).
	 */
	PVOC prism( const PrismFunc & harmonicFunction, bool perNote = true, flan_CANCEL_ARG ) const;

	//============================================================================================================================================================
	// Utility
	//============================================================================================================================================================

	/** Returns a single frame from the input. 
	 *	The returned frame in a linear interpolation of the frame surrounding the selected time.
	 *	\param time The time at which the frame should be taken. 
	 */
	PVOC getFrame( Time time ) const;

	/** This computes a weighted approximation of the 4 surrounding bins using the provided interpolator */
	MF getBinInterpolated( Channel channel, float frame, float bin, Interpolator interp = Interpolators::linear ) const;
	MF getBinInterpolated( Channel channel, float frame, Bin bin, Interpolator interp = Interpolators::linear ) const;
	MF getBinInterpolated( Channel channel, Frame frame, float bin, Interpolator interp = Interpolators::linear ) const;



	//============================================================================================================================================================
	// Selection
	//============================================================================================================================================================

	/** Every time/frequency point in the output PVOC will read an arbitrary point in the input determined by selector.
	 *	Selected non-integer coordinates will interpolate surrounding integer coordinates using interp.
	 *	\param length The length of the output PVOC
	 *	\param selector This function takes each time/frequency point in the output and returns 
	 *		the time/frequency that should be read from the input into that output
	 *	\param interpolateFrames Decides if selecting a point between frames should interpolate the surrounding frames or round to the nearest frame.
	 		Using interpolation takes around twice as long to compute.
	 *	\param interp This determines how input points surrounding selected points are interpolated
	 */
	PVOC select( Time length, const Func2x2 & selector, bool interpolateFrames = false, Interpolator interp = Interpolators::linear ) const;

	/** This is a classic "time-freeze" effect. At supplied times playback is "frozen", repeating the current frame 
	 *	(or a linear interpolation of surrounding frames), for a specified amount of time. After this time has elapsed,
	 *	playback resumes until another freeze time is encountered.
	 *	\param timing Each element of timing describes a point of time to freeze, and for 
	 *		how long it should be frozen, in that order
	 */
	PVOC freeze( const std::vector<std::array<Time,2>> & timing ) const;



	//============================================================================================================================================================
	// Resampling
	//============================================================================================================================================================

	/** Each input bin is mapped to an arbitrary output point by mod. 
	 *	Every quad in the input is thus mapped to a quad in the output. 
	 *	The output points within that quad are given an average of any data already within the bin 
	 *	and the four input bins that made up the quad being mapped.
	 *	Quad averages are decided using the interpolator argument and the algorithm described here: 
	 *	https://www.particleincell.com/2012/quad-interpolation/
	 *	\param mod Takes and returns time/frequency pairs as either flan::vec2 or std::complex<float>
	 *	\param interp Interpolator used in quad mapping
	 */
	PVOC modify( const Func2x2 & mod, Interpolator interp = Interpolators::linear ) const;

	/** This is functionally equivalent to using PVOC::modify_cpu and only outputting the input time
	 *	\param mod Takes time/frequency pairs and returns frequency
	 *	\param interp Interpolator used in frequency mapping
	 */
	PVOC modifyFrequency( const Func2x1 & mod, Interpolator = Interpolators::linear ) const;

	/** This is functionally equivalent to using PVOC::modify_cpu and only outputting the input frequency
	 *	\param mod Takes time/frequency pairs and returns time
	 *	\param interp Interpolator used in time mapping
	 */
	PVOC modifyTime( const Func2x1 & mod, Interpolator = Interpolators::linear ) const;

	/** This is functionally equivalent to using PVOC::modifyFrequency with the mod output multiplied by input frequency
	 *	\param factor Takes time/frequency pairs and returns frequency multiplier
	 *	\param interp Disabled for gpu methods.
	 */
	PVOC repitch( const Func2x1 & factor, Interpolator = Interpolators::linear ) const;

	/** This is functionally equivalent to using PVOC::modifyTime with the mod output multiplied by input time
	 *	\param factor Takes time/frequency pairs and returns time multiplier
	 *	\param interp Interpolator used in frequency mapping
	 */
	PVOC stretch( const Func2x1 & factor, Interpolator = Interpolators::linear ) const;

	/** This is close to PVOC::stretch, but can only expand the input by integer quantities at any given time.
	 *	It is also restricted to choosing the local expansion amount as a function of time, not frequency.
	 *	Spline interpolation is used to fill the expanded space.
	 *	\param expansion This returns the local expansion amount as a function of time. 
	 *		Output will be rounded to the nearest integer and clamped to positive integers.
	 */
	PVOC stretch_spline( const Func1x1 & expansion ) const;

	/** This is functionally equivalent to stretching the input down by factor, and then up.
	 *	Resolution is lost, but the lost resolution is filled via interpolation
	 *	\param factor Local information loss ratio. A factor of two will replace every other frame with interpolated data.
	 *	\param interp Interpolator deciding how lost frames are restored from their surroundings
	 */
	PVOC desample( const Func2x1 & factor, Interpolator interp = Interpolators::linear ) const;

	/** Warning: this process can produce very loud outputs with unscrupulouss parameters.
	 *	The input is left alone until startTime. Between startTime and endTime the output is an interpolation
	 *	of the frames at startTime and endTime. After endTime, the interpolation continues into the realm of extrapolation
	 *	for extrapDuration seconds. High frequency partials in the input can cause unpleasant sine sweeps in the output,
	 *	so you may want to use a mild low pass filter before processing.
	 *	\param startTime Time at which interpolation starts.
	 *	\param endTime Time at which interpolation ends and extrapolation begins. -1 indicates end of file.
	 *	\param extrapDuration Duration of the extrapolation
	 *	\param interp Interpolator used throughout
	 */
	PVOC timeExtrapolate( Time startTime, Time endTime, Time extrapDuration, Interpolator interp = Interpolators::linear) const;


	//============================================================================================================================================================
	// Generation
	//============================================================================================================================================================

	/** Generates a PVOC from a spectrum.
	 *	\param length 
	 *	\param freq
	 *	\param harmonicWeights This takes time and a harmonic index, and returns a magnitude.
	 */
	static PVOC synthesize( Time length, Func1x1 freq, const Func2x1 & harmonicWeights );



	//============================================================================================================================================================
	// Extras
	//============================================================================================================================================================

	/** For all frequencies, every octave above it is set to a copy of the base, scaled by seriesScale
	 *	\param seriesScale The scaling function. The inputs to this are time and harmonic index starting at 0.
	 */
	PVOC addOctaves( const Func2x1 & seriesScale ) const;

	/** For all frequencies, every harmonic above it is set to a copy of the base, scaled by seriesScale
	 *	\param seriesScale The scaling function. The inputs to this are time and harmonic index starting at 0.
	 */
	PVOC addHarmonics( const Func2x1 & seriesScale ) const;

	/** Replaces the Amplitudes (Magnitudes) of bins in the input with those in ampSource
	 *	\param ampSource Source PVOC from which to draw amplitudes
	 *	\param amount An amount of 1 fully replaces the amplitudes, 0 does nothing, and amounts between
	 *		give a linear interpolation of the two.
	 *	\returns A PVOC with dimensions equal to the shorter of this and ampSource
	 */
	PVOC replaceAmplitudes( const PVOC & ampSource, const Func2x1 & amount = 1 ) const;

	/** Subtracts the Amplitudes (Magnitudes) of bins in other with those in this
	 *	\param ampSource Source PVOC from which to draw amplitudes to subtract.
	 *	\param amount A scalar on the subtraction amount. This isn't clamped to [0,1].
	 *	\returns A PVOC with dimensions equal to the shorter of this and ampSource.
	 */
	PVOC subtractAmplitudes( const PVOC & other, const Func2x1 & amount = 1 ) const;

	/** Passes each MF through the shaper.
	 *	\param shaper A function which takes each input MF and returns an MF to be written to the output.
	 *	\param useShiftAlignment If enabled, for each input MF the difference between the bin the MF came from and the bin its
	 *		frequency would naturally land in is found. That is the bin shift. After shaping, rather than placing data back into the bin it 
	 *		came from, the natural bin for the shaped frequency is found, and the bin shift is added. This makes an effort to maintain the
	 *		cohesion of partials when the shaper is shifting frequency information.
	 */
	PVOC shape( const Function<MF,MF> & shaper, bool useShiftAlignment = false ) const;

	/** Modifies the input data in random ways using normal distributions.
	 *	\param magSigma Standard deviation for magnitude distribution.
	 *	\param frqSigma Standard deviation for frequency distribution.
	 *	\param damping How much each perturbation should be brought back towards zero per frame.
	 		One will do nothing, zero gives complete damping, and values over one will cause the sound to explode.
	 */
	PVOC perturb( const Func2x1 & magSigma, const Func2x1 & frqSigma, float damping = 0.99 ) const;

	/** At any given time, numPartials should return a number of bins, N, to retain.
	 *	The N loudest bins are copied to the output.
	 *	All other output bins are 0 filled.
	 *	\param numPartials Number of partials to retain as a function of time
	 */
	PVOC retainNLoudestPartials( const Function<Time, Bin> & numPartials ) const;

	/** At any given time, numPartials should return a number of bins, N, to remove.
	 *	The N loudest bin positions are 0 filled in the output.
	 *	All other bins are copied to the output.
	 *	\param numPartials Number of partials to remove as a function of time
	 */
	PVOC removeNLoudestPartials( const Function<Time, Bin> & numPartials ) const;

	/** Each bin has its frequency copied to subsequent output bins with decaying magnitude until a 
	 *	bin with magnitude greater than the current decayed magnitude is read from the input. 
	 *	The frequency of the output at that point then changes to that of the louder bin.
	 *	\param decay This returns the decay amount per second at every time/frequency input.
	 *		For example, a constant decay of .5 applied to an impulse will lose half it's magnitude every second.
	 *	\param length Because the decay is exponential, an output length is needed. 
	 */
	PVOC resonate( Time length, const Func2x1 & decay ) const;

};

} // End namespace flan

