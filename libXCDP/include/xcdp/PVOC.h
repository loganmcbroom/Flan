#pragma once

#include <string>
#include <functional>

#include "PVOCBuffer.h"
#include "xcdp/Function.h"
#include "Utility.h"

namespace xcdp {

class Audio;

//! Phase Vocoder (PVOC) Data Algorithms
/** This is a stateless wrapper of xcdp::PVOCBuffer which contains all relevant algorithms and utilities available
 *	in xcdp for manipulating PVOC buffers.
 *
 *	All methods are const and have no side effects outside of PVOC::graph, which saves a bmp file.
 *	See PVOCBuffer for a description of Phase Vocoder (PVOC) Data.
 */
class PVOC : public PVOCBuffer
{
public:

	using Vec = const std::vector<const PVOC &> &;

	/** Constructs 0 size PVOC with default PVOCBuffer::Format. */
	PVOC() : PVOCBuffer( PVOCBuffer::Format() ) {}

	/** Constructs a PVOC with the Format other but with an initialized buffer.
	 *	\param other Format for the constructed PVOC
	 */
	PVOC( const PVOCBuffer::Format & other ) : PVOCBuffer( other ) {}

	/** Constructs a PVOC from the .ana file at filename.
	 *	\param filename A .pvoc filename to load. 
			This file type is xcdp specific and is generated by PVOCBuffer::save.
	 */
	PVOC( const std::string & filename ) : PVOCBuffer( filename ) {}

	/** Transforms this PVOC to an Audio using the overlaps and samplerate given in format. */
	Audio convertToAudio() const;

	/** Creates and saves a bmp spectrograph of the PVOC.
	 *	\param filename A filename at which to save the generated bmp
	 */
	const PVOC & graph( const std::string & filename ) const;

	/** Returns a single frame from the input. 
	 *	The returned frame in a linear interpolation of the frame surrounding the selected time.
	 *	\param time The time at which the frame should be taken. 
	 */
	PVOC getFrame( float time ) const;

	/** Every time/frequency point in the output PVOC will read an arbitrary point in the input determined by selector.
	 *	Selected non-integer coordinates will interpolate surrounding integer coordinates using interp.
	 *	
	 *	\param length The length of the output PVOC
	 *	\param selector This function takes each time/frequency point in the output and returns 
	 *		the time/frequency that should be read from the input into that output
	 *	\param interp This determines how input points surrounding selected points are interpolated
	 */
	PVOC select( float length, Func2x2 selector, Interpolator interp = Interpolators::linear ) const;

	/** This is a classic "time-freeze" effect. At supplied times playback is "frozen", repeating the current frame 
	 *	(or a linear interpolation of surrounding frames), for a specified amount of time. After this time has elapsed,
	 *	playback resumes until another freeze time is encountered.
	 *	
	 *	\param timing Each element of timing describes a point of time to freeze, and for 
			how long it should be frozen, in that order
	 */
	PVOC freeze( const std::vector<std::array<float,2>> & timing ) const;

	/** Each input bin is mapped to an arbitrary output point by mod. 
	 *	Every quad in the input is thus mapped to a quad in the output. 
	 *	The output points within that quad are given an average of any data already within the bin 
	 *	and the four input bins that made up the quad being mapped.
	 *	Quad averages are decided using the interpolator argument and the algorithm described here: 
	 *	https://www.particleincell.com/2012/quad-interpolation/
	 *	
	 *	\param mod Takes and returns time/frequency pairs as either xcdp::vec2 or std::complex<float>
	 *	\param interp Interpolator used in quad mapping
	 */
	PVOC modify( Func2x2 mod, Interpolator interp = Interpolators::linear ) const;

	/** This is functionally equivalent to using PVOC::modify and only outputting the input time
	 *	
	 *	\param mod Takes time/frequency pairs and returns frequency
	 *	\param interp Interpolator used in frequency mapping
	 */
	PVOC modifyFrequency( Func2x1 mod, Interpolator = Interpolators::linear ) const;

	/** This is functionally equivalent to using PVOC::modify and only outputting the input frequency
	 *	
	 *	\param mod Takes time/frequency pairs and returns time
	 *	\param interp Interpolator used in time mapping
	 */
	PVOC modifyTime( Func2x1 mod, Interpolator = Interpolators::linear ) const;

#ifdef USE_OPENCL

	/** This is nearly identical to PVOC::modify.
	 *	Due to the computations being on the gpu in parallel it is much faster.
	 *	The cost of this speed is that the output buffer is write only, so any output bin mapped to more than once
	 *  will take one of those written values only, with no determination as to which.
	 *	
	 *	\param mod Takes and returns time/frequency pairs as either xcdp::vec2 or std::complex<float>
	 *	\param interp Interpolator used in quad mapping, this is sampled 512 times for use by OpenCL
	 */
	PVOC modify_cl( Func2x2 mod, Interpolator interp = Interpolators::linear ) const;

	/** This is functionally equivalent to using PVOC::modify_cl and only outputting the input time
	 *	See PVOC::modify_cl for the effects of non-parallel computation
	 *	
	 *	\param mod Takes time/frequency pairs and returns frequency
	 *	\param interp Interpolator used in frequency mapping, this is sampled 512 times for use by OpenCL
	 */
	PVOC modifyFrequency_cl( Func2x1 mod, Interpolator interp = Interpolators::linear ) const;

	/** This is functionally equivalent to using PVOC::modify_cl and only outputting the input frequency
	 *	See PVOC::modify_cl for the effects of non-parallel computation
	 *	
	 *	\param mod Takes time/frequency pairs and returns time
	 *	\param interp Interpolator used in time mapping, this is sampled 512 times for use by OpenCL
	 */
	PVOC modifyTime_cl( Func2x1 mod, Interpolator interp = Interpolators::linear  ) const;

#endif

	/** This is functionally equivalent to using PVOC::modifyFrequency_cl with the mod output multiplied by input frequency
	 *	
	 *	\param factor Takes time/frequency pairs and returns frequency multiplier
	 *	\param interp Interpolator used in frequency mapping
	 */
	PVOC repitch( Func2x1 factor, Interpolator = Interpolators::linear ) const;

	/** This is functionally equivalent to using PVOC::modifyTime_cl with the mod output multiplied by input time
	 *	
	 *	\param factor Takes time/frequency pairs and returns time multiplier
	 *	\param interp Interpolator used in frequency mapping
	 */
	PVOC stretch( Func2x1 factor, Interpolator = Interpolators::linear ) const;

	/** This is close to PVOC::stretch, but can only expand the input by integer quantities at any given time.
	 *	It is also restricted to only choosing the local expansion amount as a function of time.
	 *	Spline interpolation is used to fill the expanded space.
	 *
	 *	\param interp This returns the local expansion amount as a function of time. 
			Output will be rounded to the nearest integer and clamped to positive integers.
	 */
	PVOC stretch_spline( Func1x1 interp ) const; //Spline interpolation requires custom handling

	/** This computes a weighted approximation of the 4 surrounding bins using the provided interpolator */
	MF getBinInterpolated( size_t channel, float frame, float bin, Interpolator interp = Interpolators::linear ) const;
	MF getBinInterpolated( size_t channel, float frame, size_t bin, Interpolator interp = Interpolators::linear ) const;
	MF getBinInterpolated( size_t channel, size_t frame, float bin, Interpolator interp = Interpolators::linear ) const;

	/** This is functionally equivalent to stretching the input down by factor, and then up.
	 *	Resolution is lost, but the lost resolution is filled via interpolation
	 *
	 *	\param factor Local information loss ratio. A factor of two will replace every other frame with interpolated data.
	 *	\param interp Interpolator deciding how lost frames are restored from their surroundings
	 */
	PVOC desample( Func2x1 factor, Interpolator interp = Interpolators::linear ) const;

	/** Warning: this process can produce very loud outputs with unscrupulouss parameters.
	 *	The input is left alone until startTime. Between startTime and endTime the output is an interpolation
	 *	of the frames at startTime and endTime. After endTime, the interpolation continues into the realm of extrapolation
	 *	for a duration of extrapDuration.
	 *
	 *	\param startTime Time at which interpolation starts.
	 *	\param endTime Time at which interpolation ends and extrapolation begins
	 *	\param extrapDuration Duration of the extrapolation
	 *	\param interp Interpolator used throughout
	 */
	PVOC timeExtrapolate( float startTime, float endTime, float extrapDuration, Interpolator interp = Interpolators::linear ) const;

	/** Replaces the Amplitudes (Magnitudes) of bins in the input with those in ampSource
	 *
	 *	\param ampSource Source PVOC from which to draw amplitudes
	 *	\param amount An amount of 1 fully replaces the amplitudes, 0 does nothing, and amounts between
	 *		give a linear interpolation of the two.
	 *	\returns A PVOC with dimensions equal to the shorter of this and ampSource
	 */
	PVOC replaceAmplitudes( const PVOC & ampSource, Func2x1 amount = 1 ) const;

	/** Subtracts the Amplitudes (Magnitudes) of bins in other with those in this
	 *
	 *	\param ampSource Source PVOC from which to draw amplitudes to subtract
	 *	\param amount A multiplier on the subtraction amount
	 *	\returns A PVOC with dimensions equal to the shorter of this and ampSource
	 */
	PVOC subtractAmplitudes( const PVOC & other, Func2x1 amount = 1 ) const;

	/** Slightly modifies the input data in random ways with distributions given by Perturbers
	 *
	 *	\param magAmount Multiplier on how much the input magnitude can be moved by the perturber
	 *	\param frqAmount Multiplier on how much the input frequency can be moved by the perturber
	 *	\param magDistribution Describes distribution for modifying magnitude
	 *	\param frqDistribution Describes distribution for modifying frequency
	 */
	PVOC perturb( Func1x1 magAmount, Func1x1 frqAmount, 
		Distribution magDistribution = Distributions::identity, 
		Distribution frqDistribution = Distributions::normal ) const;

	/** At any given time, numPartials should return a number of bins, N, to retain.
	 *	The N loudest bins are copied to the output.
	 *	All other output bins are 0 filled.
	 *
	 *	\param numPartials Number of partials to retain as a function of time
	 */
	PVOC retainNLoudestPartials( Func1x1 numPartials ) const;

	/** At any given time, numPartials should return a number of bins, N, to remove.
	 *	The N loudest bin positions are 0 filled in the output.
	 *	All other bins are copied to the output.
	 *
	 *	\param numPartials Number of partials to remove as a function of time
	 */
	PVOC removeNLoudestPartials( Func1x1 numPartials ) const;

	/** Each bin has its frequency copied to subsequent output bins with decaying magnitude until a 
	 *	bin with magnitude greater than the current decayed magnitude is read from the input. 
	 *	The frequency of the output at that point then changes to that of the louder bin.
	 *
	 *	\param decay This returns the decay amount per second at every time/frequency input.
	 *		For example, a constant decay of .5 applied to an impulse will lose half it's magnitude every second.
	 *	\param length Because the decay is exponential, an output length is needed. 
	 */
	PVOC resonate( Func2x1 decay, float length ) const;

	//========================================================================
	// CDP Map
	//========================================================================

	// Blur
	PVOC blur_blur( Func1x1 blurring ) const;
	PVOC blur_chorus( Func1x1 fspread ) const; //mode 2

	// Combine
	PVOC combine_cross( const PVOC & infile2, Func1x1 interp = 1 ) const;

};

} // End namespace xcdp

